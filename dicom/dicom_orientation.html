<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Neuroimaging in Python &#8212; NiBabel 5.4.0.dev1+g3b1c7b37 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/nibabel.css?v=f6107aeb" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <script src="../_static/documentation_options.js?v=8f87c9ba"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="DICOM fields" href="dicom_fields.html" />
    <link rel="prev" title="DICOM information" href="dicom_info.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience">

  </head><body>
<div class="row" style="display: flex; flex-direction: row; flex-wrap: wrap; width: 100%;">
  <div class="column" style="background-color: white; display: flex; flex-direction: column; flex: 0 0 140px; padding-left: 2px; padding-bottom:2px; padding-top:2px;">
    <img src="../_static/nibabel-logo.svg" class="logo" alt="Logo" width="130px"/>
  </div>
  <div class="column" style="background-color: white; text-align: left; padding-left: 10px; padding-bottom:50px; padding-top:20px; background-repeat: no-repeat; display: flex; flex-direction: column; flex-basis: 100%; flex: 1;">
    <h1>NiBabel</h1>
    <h3 style="margin-top:-5px;color:#2f83c8">Access a cacophony of neuro-imaging file formats</h3>
  </div>
</div>

    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dicom_fields.html" title="DICOM fields"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="dicom_info.html" title="DICOM information"
             accesskey="P">previous</a> |</li>
  <li><a href="http://nipy.org/">Community</a> |&nbsp;</li>
  <li><a href="../index.html">NiBabel Home</a> |&nbsp;</li>
  <li><a href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing list</a> |&nbsp;</li>
  <li><a href="legal.html">License</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="dicom.html" accesskey="U">DICOM concepts and implementations</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Neuroimaging in Python</a></li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Defining the DICOM orientation</a><ul>
<li><a class="reference internal" href="#dicom-patient-coordinate-system">DICOM patient coordinate system</a></li>
<li><a class="reference internal" href="#dicom-pixel-data">DICOM pixel data</a></li>
<li><a class="reference internal" href="#pixel-spacing">Pixel spacing</a></li>
<li><a class="reference internal" href="#dicom-voxel-to-patient-coordinate-system-mapping">DICOM voxel to patient coordinate system mapping</a></li>
<li><a class="reference internal" href="#i-j-columns-rows-in-dicom">(i, j), columns, rows in DICOM</a></li>
<li><a class="reference internal" href="#dicom-affines-again">DICOM affines again</a></li>
<li><a class="reference internal" href="#dicom-affine-formula">DICOM affine formula</a></li>
<li><a class="reference internal" href="#getting-a-3d-affine-from-a-dicom-slice-or-list-of-slices">Getting a 3D affine from a DICOM slice or list of slices</a><ul>
<li><a class="reference internal" href="#dicom-affine-definitions">DICOM affine Definitions</a></li>
<li><a class="reference internal" href="#derivations">Derivations</a></li>
<li><a class="reference internal" href="#d-affine-formulae">3D affine formulae</a></li>
</ul>
</li>
<li><a class="reference internal" href="#working-out-the-z-coordinates-for-a-set-of-slices">Working out the Z coordinates for a set of slices</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="dicom_info.html"
                          title="previous chapter">DICOM information</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="dicom_fields.html"
                          title="next chapter">DICOM fields</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/dicom/dicom_orientation.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="defining-the-dicom-orientation">
<h1>Defining the DICOM orientation<a class="headerlink" href="#defining-the-dicom-orientation" title="Link to this heading">¶</a></h1>
<section id="dicom-patient-coordinate-system">
<span id="dicom-pcs"></span><h2>DICOM patient coordinate system<a class="headerlink" href="#dicom-patient-coordinate-system" title="Link to this heading">¶</a></h2>
<p>First we define the standard DICOM patient-based coordinate system.
This is what DICOM means by x, y and z axes in its orientation
specification.  From section C.7.6.2.1.1 of the <a class="reference external" href="ftp://medical.nema.org/medical/dicom/2011/11_03pu3.pdf">DICOM object
definitions</a> (2009):</p>
<blockquote>
<div><p>If Anatomical Orientation Type (0010,2210) is absent or has a value
of BIPED, the x-axis is increasing to the left hand side of the
patient. The y-axis is increasing to the posterior side of the
patient. The z-axis is increasing toward the head of the patient.</p>
</div></blockquote>
<p>(we’ll ignore the quadupeds for now).</p>
<p>In a way it’s funny to call this the ‘patient-based’ coordinate system.
‘Doctor-based coordinate system’ is a better name.  Think of a doctor
looking at the patient from the foot of the scanner bed.  Imagine the
doctor’s right hand held in front of her like Spiderman about to shoot a
web, with her palm towards the patient, defining a right-handed
coordinate system.  Her thumb points to her right (the patient’s left),
her index finger points down, and the middle finger points at the
patient.</p>
</section>
<section id="dicom-pixel-data">
<span id="dicom-pixel-array"></span><h2>DICOM pixel data<a class="headerlink" href="#dicom-pixel-data" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>C.7.6.3.1.4 - Pixel Data</dt><dd><p>Pixel Data (7FE0,0010) for this image. The order of pixels sent for
each image plane is left to right, top to bottom, i.e., the upper
left pixel (labeled 1,1) is sent first followed by the remainder of
row 1, followed by the first pixel of row 2 (labeled 2,1) then the
remainder of row 2 and so on.</p>
</dd>
</dl>
<p>The resulting pixel array then has size (‘Rows’, ‘Columns’), with
row-major storage (rows first, then columns).  We’ll call this the DICOM
<em>pixel array</em>.</p>
</section>
<section id="pixel-spacing">
<h2>Pixel spacing<a class="headerlink" href="#pixel-spacing" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>Section 10.7.1.3:  Pixel Spacing</dt><dd><p>The first value is the row spacing in mm, that is the spacing between
the centers of adjacent rows, or vertical spacing.  The second value
is the column spacing in mm, that is the spacing between the centers
of adjacent columns, or horizontal spacing.</p>
</dd>
</dl>
</section>
<section id="dicom-voxel-to-patient-coordinate-system-mapping">
<span id="dicom-orientation"></span><h2>DICOM voxel to patient coordinate system mapping<a class="headerlink" href="#dicom-voxel-to-patient-coordinate-system-mapping" title="Link to this heading">¶</a></h2>
<p>See:</p>
<ul class="simple">
<li><p><a class="reference external" href="http://www.dclunie.com/medical-image-faq/html/part2.html">http://www.dclunie.com/medical-image-faq/html/part2.html</a>;</p></li>
<li><p><a class="reference external" href="https://groups.google.com/forum/#!topic/comp.protocols.dicom/-Nms_GgmdRc">this dicom mailing list post</a>;</p></li>
</ul>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Direction_cosine">wikipedia direction cosine</a> for a definition of direction cosines.</p>
<p>From section C.7.6.2.1.1 of the <a class="reference external" href="ftp://medical.nema.org/medical/dicom/2011/11_03pu3.pdf">DICOM object definitions</a> (2009):</p>
<blockquote>
<div><p>The Image Position (0020,0032) specifies the x, y, and z coordinates
of the upper left hand corner of the image; it is the center of the
first voxel transmitted. Image Orientation (0020,0037) specifies the
direction cosines of the first row and the first column with respect
to the patient.  These Attributes shall be provide as a pair. Row
value for the x, y, and z axes respectively followed by the Column
value for the x, y, and z axes respectively.</p>
</div></blockquote>
<p>From Section C.7.6.1.1.1 we see that the ‘positive row axis’ is left to
right, and is the direction of the rows, given by the direction of last
pixel in the first row from the first pixel in that row.  Similarly the
‘positive column axis’ is top to bottom and is the direction of the
columns, given by the direction of the last pixel in the first column
from the first pixel in that column.</p>
<p>Let’s rephrase: the first three values of ‘Image Orientation Patient’
are the direction cosine for the ‘positive row axis’.  That is, they
express the direction change in (x, y, z), in the DICOM patient
coordinate system (DPCS), as you move along the row.  That is, as you
move from one column to the next.  That is, as the <em>column</em> array index
changes. Similarly, the second triplet of values of ‘Image Orientation
Patient’ (<code class="docutils literal notranslate"><span class="pre">img_ornt_pat[3:]</span></code> in Python), are the direction cosine for
the ‘positive column axis’, and express the direction you move, in the
DPCS, as you move from row to row, and therefore as the <em>row</em> index
changes.</p>
<p>Further down section C.7.6.2.1.1 (RCS below is the <em>reference coordinate
system</em> - see <a class="reference external" href="ftp://medical.nema.org/medical/dicom/2011/11_03pu3.pdf">DICOM object definitions</a> section 3.17.1):</p>
<blockquote>
<div><p>The Image Plane Attributes, in conjunction with the Pixel Spacing
Attribute, describe the position and orientation of the image slices
relative to the patient-based coordinate system. In each image frame
the Image Position (Patient) (0020,0032) specifies the origin of the
image with respect to the patient-based coordinate system. RCS and
the Image Orientation (Patient) (0020,0037) attribute values specify
the orientation of the image frame rows and columns. The mapping of
pixel location (i, j) to the RCS is calculated as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix} P_x\\
                P_y\\
                P_z\\
                1 \end{bmatrix} =
\begin{bmatrix} X_x\Delta{i} &amp; Y_x\Delta{j} &amp; 0 &amp; S_x \\
                X_y\Delta{i} &amp; Y_y\Delta{j} &amp; 0 &amp; S_y \\
                X_z\Delta{i} &amp; Y_z\Delta{j} &amp; 0 &amp; S_z \\
                0   &amp; 0   &amp; 0 &amp; 1 \end{bmatrix}
\begin{bmatrix} i\\
                j\\
                0\\
                1 \end{bmatrix}
= M
\begin{bmatrix} i\\
                j\\
                0\\
                1 \end{bmatrix}\end{split}\]</div>
<p>Where:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(P_{xyz}\)</span> : The coordinates of the voxel (i,j) in the frame’s
image plane in units of mm.</p></li>
<li><p><span class="math notranslate nohighlight">\(S_{xyz}\)</span> : The three values of the Image Position (Patient)
(0020,0032) attributes. It is the location in mm from the origin
of the RCS.</p></li>
<li><p><span class="math notranslate nohighlight">\(X_{xyz}\)</span> : The values from the row (X) direction cosine of the
Image Orientation (Patient) (0020,0037) attribute.</p></li>
<li><p><span class="math notranslate nohighlight">\(Y_{xyz}\)</span> : The values from the column (Y) direction cosine of the
Image Orientation (Patient) (0020,0037) attribute.</p></li>
<li><p><span class="math notranslate nohighlight">\(i\)</span> : Column index to the image plane. The first column is index
zero.</p></li>
<li><p><span class="math notranslate nohighlight">\(\Delta{i}\)</span>: Column pixel resolution of the Pixel Spacing
(0028,0030) attribute in units of mm.</p></li>
<li><p><span class="math notranslate nohighlight">\(j\)</span> : Row index to the image plane. The first row index is zero.</p></li>
<li><p><span class="math notranslate nohighlight">\(\Delta{j}\)</span> - Row pixel resolution of the Pixel Spacing
(0028,0030) attribute in units of mm.</p></li>
</ol>
</div></blockquote>
</section>
<section id="i-j-columns-rows-in-dicom">
<span id="ij-transpose"></span><h2>(i, j), columns, rows in DICOM<a class="headerlink" href="#i-j-columns-rows-in-dicom" title="Link to this heading">¶</a></h2>
<p>We stop to ask ourselves, what does DICOM mean by voxel (i, j)?</p>
<p>Isn’t that obvious?  Oh dear, no it isn’t.  See the
<a class="reference internal" href="#dicom-orientation"><span class="std std-ref">DICOM voxel to patient coordinate system mapping</span></a> formula above.  In particular, you’ll see:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(i\)</span> : Column index to the image plane. The first column is index zero.</p></li>
<li><p><span class="math notranslate nohighlight">\(j\)</span> : Row index to the image plane. The first row index is zero.</p></li>
</ul>
<p>That is, if we have the <a class="reference internal" href="#dicom-pixel-array"><span class="std std-ref">DICOM pixel data</span></a> as defined above, and
we call that <code class="docutils literal notranslate"><span class="pre">pixel_array</span></code>, then voxel (i, j) in the notation above is
given by <code class="docutils literal notranslate"><span class="pre">pixel_array[j,</span> <span class="pre">i]</span></code>.</p>
<p>What does this mean?  It means that, if we want to apply the formula
above to array indices in <code class="docutils literal notranslate"><span class="pre">pixel_array</span></code>, we first have to apply a
column / row flip to the indices.  Say <span class="math notranslate nohighlight">\(M_{pixar}\)</span> (sorry) is the affine
to go from array indices in <code class="docutils literal notranslate"><span class="pre">pixel_array</span></code> to mm in the DPCS.  Then,
given <span class="math notranslate nohighlight">\(M\)</span> above:</p>
<div class="math notranslate nohighlight">
\[\begin{split}M_{pixar} = M \left(\begin{smallmatrix}0 &amp; 1 &amp; 0 &amp; 0\\1 &amp; 0 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 1 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{smallmatrix}\right)\end{split}\]</div>
</section>
<section id="dicom-affines-again">
<span id="dicom-affines-reloaded"></span><h2>DICOM affines again<a class="headerlink" href="#dicom-affines-again" title="Link to this heading">¶</a></h2>
<p>The <a class="reference internal" href="#ij-transpose"><span class="std std-ref">(i, j), columns, rows in DICOM</span></a> is rather confusing, so we’re going to rephrase
the affine mapping; we’ll use <span class="math notranslate nohighlight">\(r\)</span> for the row index (instead of <span class="math notranslate nohighlight">\(j\)</span>
above), and <span class="math notranslate nohighlight">\(c\)</span> for the column index (instead of <span class="math notranslate nohighlight">\(i\)</span>).</p>
<p>Next we define a flipped version of ‘ImageOrientationPatient’, <span class="math notranslate nohighlight">\(F\)</span>, that
has flipped columns. Thus if the vector of 6 values in
‘ImageOrientationPatient’ are <span class="math notranslate nohighlight">\((i_1 .. i_6)\)</span>, then:</p>
<div class="math notranslate nohighlight">
\[\begin{split}F =  \begin{bmatrix} i_4 &amp; i_1 \\
                     i_5 &amp; i_2 \\
                     i_6 &amp; i_3 \end{bmatrix}\end{split}\]</div>
<p>Now the first column of F contains what the DICOM docs call the ‘column
(Y) direction cosine’, and second column contains the ‘row (X) direction
cosine’.  We prefer to think of these as (respectively) the row index
direction cosine and the column index direction cosine.</p>
<p>Now we can rephrase the DICOM affine mapping with:</p>
</section>
<section id="dicom-affine-formula">
<span id="dicom-slice-affine"></span><h2>DICOM affine formula<a class="headerlink" href="#dicom-affine-formula" title="Link to this heading">¶</a></h2>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix} P_x\\
                P_y\\
                P_z\\
                1 \end{bmatrix} =
\begin{bmatrix} F_{11}\Delta{r} &amp; F_{12}\Delta{c} &amp; 0 &amp; S_x \\
                F_{21}\Delta{r} &amp; F_{22}\Delta{c} &amp; 0 &amp; S_y \\
                F_{31}\Delta{r} &amp; F_{32}\Delta{c} &amp; 0 &amp; S_z \\
                0   &amp; 0   &amp; 0 &amp; 1 \end{bmatrix}
\begin{bmatrix} r\\
                c\\
                0\\
                1 \end{bmatrix}
= A
\begin{bmatrix} r\\
                c\\
                0\\
                1 \end{bmatrix}\end{split}\]</div>
<p>Where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(P_{xyz}\)</span> : The coordinates of the voxel (c, r) in the frame’s image
plane in units of mm.</p></li>
<li><p><span class="math notranslate nohighlight">\(S_{xyz}\)</span> : The three values of the Image Position (Patient)
(0020,0032) attributes. It is the location in mm from the origin of
the RCS.</p></li>
<li><p><span class="math notranslate nohighlight">\(F_{:,1}\)</span> : The values from the column (Y) direction cosine of the
Image Orientation (Patient) (0020,0037) attribute - see above.</p></li>
<li><p><span class="math notranslate nohighlight">\(F_{:,2}\)</span> : The values from the row (X) direction cosine of the Image
Orientation (Patient) (0020,0037) attribute - see above.</p></li>
<li><p><span class="math notranslate nohighlight">\(r\)</span> : Row index to the image plane. The first row index is zero.</p></li>
<li><p><span class="math notranslate nohighlight">\(\Delta{r}\)</span> - Row pixel resolution of the Pixel Spacing (0028,0030)
attribute in units of mm.</p></li>
<li><p><span class="math notranslate nohighlight">\(c\)</span> : Column index to the image plane. The first column is index zero.</p></li>
<li><p><span class="math notranslate nohighlight">\(\Delta{c}\)</span>: Column pixel resolution of the Pixel Spacing (0028,0030)
attribute in units of mm.</p></li>
</ul>
<p>For later convenience we also define values useful for 3D volumes:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(s\)</span> : Slice index to the slice plane. The first slice index is zero.</p></li>
<li><p><span class="math notranslate nohighlight">\(\Delta{s}\)</span> - Spacing in mm between slices.</p></li>
</ul>
</section>
<section id="getting-a-3d-affine-from-a-dicom-slice-or-list-of-slices">
<span id="dicom-3d-affines"></span><h2>Getting a 3D affine from a DICOM slice or list of slices<a class="headerlink" href="#getting-a-3d-affine-from-a-dicom-slice-or-list-of-slices" title="Link to this heading">¶</a></h2>
<p>Let us say, we have a single DICOM file, or a list of DICOM files that
we believe to be a set of slices from the same volume.  We’ll call the
first the <em>single slice</em> case, and the second, <em>multi slice</em>.</p>
<p>In the <em>multi slice</em> case, we can assume that the
‘ImageOrientationPatient’ field is the same for all the slices.</p>
<p>We want to get the affine transformation matrix <span class="math notranslate nohighlight">\(A\)</span> that maps from voxel
coordinates in the DICOM file(s), to mm in the <a class="reference internal" href="#dicom-pcs"><span class="std std-ref">DICOM patient coordinate system</span></a>.</p>
<p>By voxel coordinates, we mean coordinates of form <span class="math notranslate nohighlight">\((r, c, s)\)</span> - the row,
column and slice indices - as for the <a class="reference internal" href="#dicom-slice-affine"><span class="std std-ref">DICOM affine formula</span></a>.</p>
<p>In the single slice case, the voxel coordinates are just the indices
into the pixel array, with the third (slice) coordinate always being 0.</p>
<p>In the multi-slice case, we have arranged the slices in ascending or
descending order, where slice numbers range from 0 to <span class="math notranslate nohighlight">\(N-1\)</span> - where <span class="math notranslate nohighlight">\(N\)</span>
is the number of slices - and the slice coordinate is a number on this
scale.</p>
<p>We know, from <a class="reference internal" href="#dicom-slice-affine"><span class="std std-ref">DICOM affine formula</span></a>, that the first, second and
fourth columns in <span class="math notranslate nohighlight">\(A\)</span> are given directly by the (flipped)
‘ImageOrientationPatient’, ‘PixelSpacing’ and ‘ImagePositionPatient’
field of the first (or only) slice.</p>
<p>Our job then is to fill the first three rows of the third column of <span class="math notranslate nohighlight">\(A\)</span>.
Let’s call this the vector <span class="math notranslate nohighlight">\(\mathbf{k}\)</span> with values  <span class="math notranslate nohighlight">\(k_1, k_2, k_3\)</span>.</p>
<section id="dicom-affine-definitions">
<span id="dicom-affine-defs"></span><h3>DICOM affine Definitions<a class="headerlink" href="#dicom-affine-definitions" title="Link to this heading">¶</a></h3>
<p>See also the definitions in <a class="reference internal" href="#dicom-slice-affine"><span class="std std-ref">DICOM affine formula</span></a>.   In addition</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(T^1\)</span> is the 3 element vector of the ‘ImagePositionPatient’ field of
the first header in the list of headers for this volume.</p></li>
<li><p><span class="math notranslate nohighlight">\(T^N\)</span> is the ‘ImagePositionPatient’ vector for the last header in the
list for this volume, if there is more than one header in the volume.</p></li>
<li><p>vector <span class="math notranslate nohighlight">\(\mathbf{n} = (n_1, n_2, n_3)\)</span> is the result of taking the
cross product of the two columns of <span class="math notranslate nohighlight">\(F\)</span> from
<a class="reference internal" href="#dicom-slice-affine"><span class="std std-ref">DICOM affine formula</span></a>.</p></li>
</ul>
</section>
<section id="derivations">
<h3>Derivations<a class="headerlink" href="#derivations" title="Link to this heading">¶</a></h3>
<p>For the single slice case we just fill <span class="math notranslate nohighlight">\(\mathbf{k}\)</span> with <span class="math notranslate nohighlight">\(\mathbf{n} \cdot
\Delta{s}\)</span> - on the basis that the Z dimension should be
right-handed orthogonal to the X and Y directions.</p>
<p>For the multi-slice case, we can fill in <span class="math notranslate nohighlight">\(\mathbf{k}\)</span> by using the information
from <span class="math notranslate nohighlight">\(T^N\)</span>, because <span class="math notranslate nohighlight">\(T^N\)</span> is the translation needed to take the
first voxel in the last (slice index = <span class="math notranslate nohighlight">\(N-1\)</span>) slice to mm space.  So:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left(\begin{smallmatrix}T^N\\1\end{smallmatrix}\right) = A \left(\begin{smallmatrix}0\\0\\N - 1\\1\end{smallmatrix}\right)\end{split}\]</div>
<p>From this it follows that:</p>
<div class="math notranslate nohighlight">
\[\begin{Bmatrix}k_{{1}} : \frac{T^{N}_{{1}} - T^{1}_{{1}}}{N - 1}, &amp; k_{{2}} : \frac{T^{N}_{{2}} - T^{1}_{{2}}}{N - 1}, &amp; k_{{3}} : \frac{T^{N}_{{3}} - T^{1}_{{3}}}{N - 1}\end{Bmatrix}\]</div>
<p>and therefore:</p>
</section>
<section id="d-affine-formulae">
<span id="dicom-3d-affine-formulae"></span><h3>3D affine formulae<a class="headerlink" href="#d-affine-formulae" title="Link to this heading">¶</a></h3>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}A_{multi} = \left(\begin{smallmatrix}F_{{11}} \Delta{r} &amp; F_{{12}} \Delta{c} &amp; \frac{T^{N}_{{1}} - T^{1}_{{1}}}{N - 1} &amp; T^{1}_{{1}}\\F_{{21}} \Delta{r} &amp; F_{{22}} \Delta{c} &amp; \frac{T^{N}_{{2}} - T^{1}_{{2}}}{N - 1} &amp; T^{1}_{{2}}\\F_{{31}} \Delta{r} &amp; F_{{32}} \Delta{c} &amp; \frac{T^{N}_{{3}} - T^{1}_{{3}}}{N - 1} &amp; T^{1}_{{3}}\\0 &amp; 0 &amp; 0 &amp; 1\end{smallmatrix}\right)\end{split}\\\begin{split}A_{single} = \left(\begin{smallmatrix}F_{{11}} \Delta{r} &amp; F_{{12}} \Delta{c} &amp; \Delta{s} n_{{1}} &amp; T^{1}_{{1}}\\F_{{21}} \Delta{r} &amp; F_{{22}} \Delta{c} &amp; \Delta{s} n_{{2}} &amp; T^{1}_{{2}}\\F_{{31}} \Delta{r} &amp; F_{{32}} \Delta{c} &amp; \Delta{s} n_{{3}} &amp; T^{1}_{{3}}\\0 &amp; 0 &amp; 0 &amp; 1\end{smallmatrix}\right)\end{split}\end{aligned}\end{align} \]</div>
<p>See <a class="reference download internal" download="" href="../_downloads/a0359552c75a1df40c301397f03c7556/spm_dicom_orient.py"><code class="xref download docutils literal notranslate"><span class="pre">derivations/spm_dicom_orient.py</span></code></a> for the derivations and
some explanations.</p>
<p>For a single slice <span class="math notranslate nohighlight">\(N=1\)</span> the affine matrix is <span class="math notranslate nohighlight">\(A_{single}\)</span>. In this
case, the slice spacing <span class="math notranslate nohighlight">\(\Delta{s}\)</span> may be obtained by the Spacing
Between Slices (0018,0088) attribute in units of mm, if it exists.</p>
</section>
</section>
<section id="working-out-the-z-coordinates-for-a-set-of-slices">
<span id="dicom-z-from-slice"></span><h2>Working out the Z coordinates for a set of slices<a class="headerlink" href="#working-out-the-z-coordinates-for-a-set-of-slices" title="Link to this heading">¶</a></h2>
<p>We may have the problem (see e.g. <a class="reference internal" href="spm_dicom.html#spm-volume-sorting"><span class="std std-ref">Sorting files into volumes</span></a>) of trying
to sort a set of slices into anatomical order.  For this we want to use
the orientation information to tell us where the slices are in space,
and therefore, what order they should have.</p>
<p>To do this sorting, we need something that is proportional, plus a
constant, to the voxel coordinate for the slice (the value for the slice
index).</p>
<p>Our DICOM might have the ‘SliceLocation’ field (0020,1041).
‘SliceLocation’ seems to be proportional to slice location, at least for
some GE and Philips DICOMs I was looking at.  But, there is a more
reliable way (that doesn’t depend on this field), and uses only the very
standard ‘ImageOrientationPatient’ and ‘ImagePositionPatient’ fields.</p>
<p>Consider the case where we have a set of slices, of unknown order, from
the same volume.</p>
<p>Now let us say we have one of these slices - slice <span class="math notranslate nohighlight">\(i\)</span>.  We have the
affine for this slice from the calculations above, for a single slice
(<span class="math notranslate nohighlight">\(A_{single}\)</span>).</p>
<p>Now let’s say we have another slice <span class="math notranslate nohighlight">\(j\)</span> from the same volume.  It will
have the same affine, except that the ‘ImagePositionPatient’ field will
change to reflect the different position of this slice in space. Let us
say that there a translation of <span class="math notranslate nohighlight">\(d\)</span> slices between <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.  If
<span class="math notranslate nohighlight">\(A_i\)</span> (<span class="math notranslate nohighlight">\(A\)</span> for slice <span class="math notranslate nohighlight">\(i\)</span>) is <span class="math notranslate nohighlight">\(A_{single}\)</span> then <span class="math notranslate nohighlight">\(A_j\)</span> for <span class="math notranslate nohighlight">\(j\)</span> is given
by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}A_j = A_{single} \left(\begin{smallmatrix}1 &amp; 0 &amp; 0 &amp; 0\\0 &amp; 1 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 1 &amp; d\\0 &amp; 0 &amp; 0 &amp; 1\end{smallmatrix}\right)\end{split}\]</div>
<p>and ‘ImagePositionPatient’ for <span class="math notranslate nohighlight">\(j\)</span> is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}T^j = \left(\begin{smallmatrix}T^{1}_{{1}} + \Delta{s} d n_{{1}}\\T^{1}_{{2}} + \Delta{s} d n_{{2}}\\T^{1}_{{3}} + \Delta{s} d n_{{3}}\end{smallmatrix}\right)\end{split}\]</div>
<p>Remember that the third column of <span class="math notranslate nohighlight">\(A\)</span> gives the vector resulting from a
unit change in the slice voxel coordinate.  So, the
‘ImagePositionPatient’ of slice - say slice <span class="math notranslate nohighlight">\(j\)</span> - can be thought of the
addition of two vectors <span class="math notranslate nohighlight">\(T^j = \mathbf{a} + \mathbf{b}\)</span>, where
<span class="math notranslate nohighlight">\(\mathbf{a}\)</span> is the position of the first voxel in some slice (here
slice 1, therefore <span class="math notranslate nohighlight">\(\mathbf{a} = T^1\)</span>) and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> is <span class="math notranslate nohighlight">\(d\)</span> times the
third column of <span class="math notranslate nohighlight">\(A\)</span>.  Obviously <span class="math notranslate nohighlight">\(d\)</span> can be negative or positive. This
leads to various ways of recovering something that is proportional to
<span class="math notranslate nohighlight">\(d\)</span> plus a constant.  The algorithm suggested in this <a class="reference external" href="http://www.itk.org/pipermail/insight-users/2003-September/004762.html">ITK post on
ordering slices</a> - and the one used by SPM - is to take the inner
product of <span class="math notranslate nohighlight">\(T^j\)</span> with the unit vector component of third column of
<span class="math notranslate nohighlight">\(A_j\)</span> - in the descriptions here, this is the vector <span class="math notranslate nohighlight">\(\mathbf{n}\)</span>:</p>
<div class="math notranslate nohighlight">
\[T^j \cdot \mathbf{c} = \left(\begin{smallmatrix}T^{1}_{{1}} n_{{1}} + T^{1}_{{2}} n_{{2}} + T^{1}_{{3}} n_{{3}} + \Delta{s} d n_{{1}}^{2} + \Delta{s} d n_{{2}}^{2} + \Delta{s} d n_{{3}}^{2}\end{smallmatrix}\right)\]</div>
<p>This is the distance of ‘ImagePositionPatient’ along the slice direction
cosine.</p>
<p>The unknown <span class="math notranslate nohighlight">\(T^1\)</span> terms pool into a constant, and the operation has the
neat feature that, because the <span class="math notranslate nohighlight">\(n_{123}^2\)</span> terms, by definition, sum to 1,
the whole can be expressed as <span class="math notranslate nohighlight">\(\lambda + \Delta{s} d\)</span> - i.e. it is
equal to the slice voxel size (<span class="math notranslate nohighlight">\(\Delta{s}\)</span>) multiplied by <span class="math notranslate nohighlight">\(d\)</span>,
plus a constant.</p>
<p>Again, see <a class="reference download internal" download="" href="../_downloads/a0359552c75a1df40c301397f03c7556/spm_dicom_orient.py"><code class="xref download docutils literal notranslate"><span class="pre">derivations/spm_dicom_orient.py</span></code></a> for the derivations.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2006, NiBabel developers &lt;neuroimaging@python.org&gt;.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.0.2.
    </div>
  </body>
</html>