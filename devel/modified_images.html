<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Neuroimaging in Python &#8212; NiBabel 5.4.0.dev1+g3b1c7b37 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/nibabel.css?v=f6107aeb" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <script src="../_static/documentation_options.js?v=8f87c9ba"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Scalefactors and intercepts" href="scaling.html" />
    <link rel="prev" title="Image use-cases in SPM" href="spm_use.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience">

  </head><body>
<div class="row" style="display: flex; flex-direction: row; flex-wrap: wrap; width: 100%;">
  <div class="column" style="background-color: white; display: flex; flex-direction: column; flex: 0 0 140px; padding-left: 2px; padding-bottom:2px; padding-top:2px;">
    <img src="../_static/nibabel-logo.svg" class="logo" alt="Logo" width="130px"/>
  </div>
  <div class="column" style="background-color: white; text-align: left; padding-left: 10px; padding-bottom:50px; padding-top:20px; background-repeat: no-repeat; display: flex; flex-direction: column; flex-basis: 100%; flex: 1;">
    <h1>NiBabel</h1>
    <h3 style="margin-top:-5px;color:#2f83c8">Access a cacophony of neuro-imaging file formats</h3>
  </div>
</div>

    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="scaling.html" title="Scalefactors and intercepts"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="spm_use.html" title="Image use-cases in SPM"
             accesskey="P">previous</a> |</li>
  <li><a href="http://nipy.org/">Community</a> |&nbsp;</li>
  <li><a href="../index.html">NiBabel Home</a> |&nbsp;</li>
  <li><a href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing list</a> |&nbsp;</li>
  <li><a href="legal.html">License</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >Developer documentation page</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="devdiscuss.html" accesskey="U">Developer discussions</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Neuroimaging in Python</a></li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Keeping track of whether images have been modified since load</a><ul>
<li><a class="reference internal" href="#summary">Summary</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#possible-implementation">Possible implementation</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="spm_use.html"
                          title="previous chapter">Image use-cases in SPM</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="scaling.html"
                          title="next chapter">Scalefactors and intercepts</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/devel/modified_images.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="keeping-track-of-whether-images-have-been-modified-since-load">
<h1>Keeping track of whether images have been modified since load<a class="headerlink" href="#keeping-track-of-whether-images-have-been-modified-since-load" title="Link to this heading">¶</a></h1>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h2>
<p>This is a discussion of a missing feature in nibabel: the ability to keep
track of whether an image object in memory still corresponds to an image file
(or files) on disk.</p>
</section>
<section id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="Link to this heading">¶</a></h2>
<p>We may need to know whether the image in memory corresponds to the image file
on disk.</p>
<p>For example, we often need to get filenames for images when passing
images to external programs. Imagine a realignment, in this case, in <a class="reference external" href="http://nipy.org/nipy">nipy</a>
(the package):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">nipy</span>
<span class="n">img1</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;meanfunctional.nii&#39;</span><span class="p">)</span>
<span class="n">img2</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;anatomical.nii&#39;</span><span class="p">)</span>
<span class="n">realigner</span> <span class="o">=</span> <span class="n">nipy</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">fsl</span><span class="o">.</span><span class="n">flirt</span><span class="p">()</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">realigner</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">img1</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">img2</span><span class="p">)</span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">nipy.interfaces.fsl.flirt.run</span></code> there may at some point be calls like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">source_filename</span> <span class="o">=</span> <span class="n">nipy</span><span class="o">.</span><span class="n">as_filename</span><span class="p">(</span><span class="n">source_img</span><span class="p">)</span>
<span class="n">target_filename</span> <span class="o">=</span> <span class="n">nipy</span><span class="o">.</span><span class="n">as_filename</span><span class="p">(</span><span class="n">target_img</span><span class="p">)</span>
</pre></div>
</div>
<p>As the authors of the <code class="docutils literal notranslate"><span class="pre">flirt.run</span></code> method, we need to make sure that the
<code class="docutils literal notranslate"><span class="pre">source_filename</span></code> corresponds to the <code class="docutils literal notranslate"><span class="pre">source_img</span></code>.</p>
<p>Of course, in the general case, if <code class="docutils literal notranslate"><span class="pre">source_img</span></code> has no corresponding
filename (from <code class="docutils literal notranslate"><span class="pre">source_img.get_filename()</span></code>, then we will have to save a copy
to disk, maybe with a temporary filename, and return that temporary name as
<code class="docutils literal notranslate"><span class="pre">source_filename</span></code>.</p>
<p>In our particular case, <code class="docutils literal notranslate"><span class="pre">source_img</span></code> does have a filename
(<code class="docutils literal notranslate"><span class="pre">meanfunctional.nii</span></code>).  We would like to return that as
<code class="docutils literal notranslate"><span class="pre">source_filename</span></code>.  The question is, how can we be sure that the user has
done nothing to <code class="docutils literal notranslate"><span class="pre">source_img</span></code> to make it diverge from its original state?
Could <code class="docutils literal notranslate"><span class="pre">source_img</span></code> have diverged, in memory, from the state recorded in
<code class="docutils literal notranslate"><span class="pre">meantunctional.nii</span></code>?</p>
<p>If the image and file have not diverged, we return <code class="docutils literal notranslate"><span class="pre">meanfunctional.nii</span></code> as
the <code class="docutils literal notranslate"><span class="pre">source_filename</span></code>, otherwise we will have to do something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tempfile</span>
<span class="n">fname</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span><span class="s1">&#39;.nii&#39;</span><span class="p">)</span>
<span class="n">img</span> <span class="o">=</span> <span class="n">source_img</span><span class="o">.</span><span class="n">to_filename</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
</pre></div>
</div>
<p>and return <code class="docutils literal notranslate"><span class="pre">fname</span></code> as <code class="docutils literal notranslate"><span class="pre">source_filename</span></code>.</p>
<p>Another situation where we might like to pass around image objects that are
known to correspond to images on disk is when working in parallel. A set of
nodes may have fast common access to a filesystem on which the images are
stored.  If a master is farming out images to nodes, a master node
distribution jobs to workers might want to check if the image was identical to
something on file and pass around a lightweight (proxied) image (with the data
not loaded into memory), relying on the node pulling the image from disk when
it uses it.</p>
</section>
<section id="possible-implementation">
<h2>Possible implementation<a class="headerlink" href="#possible-implementation" title="Link to this heading">¶</a></h2>
<p>One implementation is to have <code class="docutils literal notranslate"><span class="pre">dirty</span></code> flag, which, if set, would tell
you that the image might not correspond to the disk file.  We set this
flag when anyone asks for the data, on the basis that the user may then
do something to the data and you can’t know if they have:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">img</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;some_image.nii&#39;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span>
<span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">img2</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;some_image.nii&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">img2</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span> <span class="o">==</span> <span class="n">img</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">())</span>
</pre></div>
</div>
<p>The image consists of the data, the affine and a header.  In order to
keep track of the header and affine, we could cache them when loading
the image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">img</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;some_image.nii&#39;</span><span class="p">)</span>
<span class="n">hdr</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">header</span>
<span class="k">assert</span> <span class="n">img</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;header&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">img</span><span class="o">.</span><span class="n">header</span>
<span class="n">hdr</span><span class="o">.</span><span class="n">set_data_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">img</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;header&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">img</span><span class="o">.</span><span class="n">header</span>
</pre></div>
</div>
<p>When we need to know whether the image object and image file correspond, we
could check the current header and current affine (the header may be separate
from the affine for an SPM Analyze image) against their cached copies, if they
are the same and the ‘dirty’ flag has not been set by a previous call to
<code class="docutils literal notranslate"><span class="pre">get_fdata()</span></code>, we know that the image file does correspond to the image
object.</p>
<p>This may be OK for small bits of memory like the affine and the header,
but would quickly become prohibitive for larger image metadata such as
large nifti header extensions.  We could just always assume that images
with large header extensions are <em>not</em> the same as for on disk.</p>
<p>The user might be able to override the result of these checks directly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">img</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;some_image.nii&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">img</span><span class="o">.</span><span class="n">is_dirty</span> <span class="o">==</span> <span class="kc">False</span>
<span class="n">hdr</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">header</span>
<span class="n">hdr</span><span class="o">.</span><span class="n">set_data_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">img</span><span class="o">.</span><span class="n">is_dirty</span> <span class="o">==</span> <span class="kc">True</span>
<span class="n">img</span><span class="o">.</span><span class="n">is_dirty</span> <span class="o">==</span> <span class="kc">False</span>
</pre></div>
</div>
<p>The checks are magic behind the scenes stuff that do some safe optimization
(in the sense that we are not re-saving the data if that is not necessary),
but drops back to the default (re-saving the data) if there is any
uncertainty, or the cost is too high to be able to check.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2006, NiBabel developers &lt;neuroimaging@python.org&gt;.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.0.2.
    </div>
  </body>
</html>